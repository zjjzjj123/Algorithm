class Solution {
    public int rob(int[] nums) {  //背包问题
        //求最值 可能用到动态规划
        //不能获取相邻房间的数字 
        //求最值  看看能不能用递归 
        //状态最优解为f[n] 金额 那么他只能在f[n-2] ... f[0] 这些房间偷取金币 这就是个子问题
        //dp[n] 存放可以窃取这个房间的金额 并且加上前面的最优解金额
        //约束 0 [2--n] [1] [3--n]
        if(nums.length == 0|| nums == null ) return 0; 
        if(nums.length == 1) return nums[0];
        int[] dp = new int[nums.length]; //定义多大呢 因为他是隔一个偷取 所以最多能得到的种类数值为n/2+1
        //初始化条件  //
        Arrays.fill(dp,-1); //因为选择最大的
        dp[0] = nums[0]; //初始化  如果创建 +1个数组就必须为0
        dp[1] = Math.max(nums[1],nums[0]); //不一定非要有两个for 
        for(int i=2; i<nums.length; i++)
        {   
          //从剩下的房间里偷取  后面的还没有
          //当最后一个房间f(n)  f(n-2) + f[n] 不被偷 f(n-1)
            dp[i] = Math.max(dp[i-2] + nums[i], dp[i-1]);
        }   
        return dp[nums.length - 1];
    }
}